<html>

<head>
	<title>Transept de la cathédrale d'Amiens</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
	<script src="Libs/three.min.js"></script>
	<script src="Libs/OBJLoader.js"></script>
	<script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>

	<script>
		var container;

		var camera, scene, renderer;
		var dax = 0.002;

		var keyboard = {};
		var player = { speed: 0.05, turnSpeed: Math.PI * 0.005 };

		var coordCubes = [[4, 8], [-3, 6], [5, -10]];
		var coordCubesOriginal = Array();
		var nbCubes = 0;

		function onWindowResize() {
			camera.aspect = (window.innerWidth - 20) / (window.innerHeight - 50);
			camera.updateProjectionMatrix();
			renderer.setSize((window.innerWidth - 20), (window.innerHeight - 50));
		}

		function generateStructure(manager) {
			var texture = new THREE.Texture();

			var loader = new THREE.ImageLoader(manager);
			loader.load('../TranseptSud/TranseptTexture4096.jpg', function (image) {
				texture.image = image;
				texture.needsUpdate = true;

			});

			// Chargement du modèle
			var loader = new THREE.OBJLoader(manager);
			loader.load('../TranseptSud/transeptSudBox.obj', function (object) {
				object.traverse(function (child) {
					if (child instanceof THREE.Mesh) {
						child.material = new THREE.MeshPhongMaterial({ map: texture });
						child.material.map = texture;
					}
				});
				object.name = "cathédrale";
				object.receiveShadow = true;
				object.rotation.x = 11;
				batiment = object;
				scene.add(object);
			});
		}

		function Init() {
			container = document.createElement('div');
			document.body.appendChild(container);

			havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if (havePointerLock) {

				element = document.body;

				var pointerlockchange = function (event) {

					if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
						controls.enabled = true;
					} else {
						controls.enabled = false;
					}

				};

				var pointerlockerror = function (event) {
					console.log('Error loading Pointer Lock');
				};

				// Hook pointer lock state change events
				document.addEventListener('pointerlockchange', pointerlockchange, false);
				document.addEventListener('mozpointerlockchange', pointerlockchange, false);
				document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

				document.addEventListener('pointerlockerror', pointerlockerror, false);
				document.addEventListener('mozpointerlockerror', pointerlockerror, false);
				document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

				element.addEventListener('click', function (event) {

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if (/Firefox/i.test(navigator.userAgent)) {

						var fullscreenchange = function (event) {

							if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {

								document.removeEventListener('fullscreenchange', fullscreenchange);
								document.removeEventListener('mozfullscreenchange', fullscreenchange);

								element.requestPointerLock();
							}

						};

						document.addEventListener('fullscreenchange', fullscreenchange, false);
						document.addEventListener('mozfullscreenchange', fullscreenchange, false);

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false);

			} else {
				console.error('Your browser doesn\'t support the pointer lock API');
			}

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth - 20, window.innerHeight - 50);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			container.appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);

			camera = new THREE.PerspectiveCamera(90, (window.innerWidth - 20) / (window.innerHeight - 50), 0.1, 2000);
			camera.rotation.z = 0;
			camera.rotation.x = 0;
			camera.rotation.y = Math.PI;
			camera.position.z = 0;
			camera.position.y = 0;
			camera.position.y = -20.5;

			// scene
			scene = new THREE.Scene();

			var ambient = new THREE.AmbientLight(0xffffff, 0.04);
			scene.add( ambient );

			const light = new THREE.SpotLight(0xffddaa, 1.5);
			light.angle = -Math.PI / 4;
			light.distance = 8;
			light.penumbra = 0.2;
			light.position = camera.position;
			light.position.y -= 1.625;
			light.position.x += 1;
			light.rotation = camera.rotation;
			light.target.position.x = 0;
			light.target.position.y = -0.75;
			light.target.position.z = -10;
			light.castShadow = true;
			light.shadow.mapSize.width = 1024;
			light.shadow.mapSize.height = 1024;
			light.shadow.camera.near = 0.1;
			light.shadow.camera.far = 50;   
			camera.add(light);
			camera.add(light.target);
			camera.position.z -= 1;

			controls = new THREE.PointerLockControls(camera);
			controls.enabled = false;
			scene.add(controls.getObject());

			// texture
			var manager = new THREE.LoadingManager();
			manager.onProgress = function (item, loaded, total) {
				console.log(item, loaded, total);
			};

			generateStructure(manager);

			// cubes
			let indexCubeCreate = 0
			coordCubes.forEach(function(coordCube) {
				coordCubesOriginal.push(coordCube)
				let geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
				let material = new THREE.MeshStandardMaterial()
				material.color.set("#e0b000")
				let cube = new THREE.Mesh(geometry, material);
				cube.position.set(coordCube[0], -21.5, coordCube[1]);
				cube.castShadow = true;
				cube.receiveShadow = true;
				cube.name = "cube" + indexCubeCreate;
				console.log(cube.name);
				indexCubeCreate++;
				console.log("cube placé !\nx=" + cube.position.x + "\ny=" + cube.position.y + "\nz=" + cube.position.z);
				scene.add(cube);
			});

		}
		function Afficher() {
			renderer.render(scene, camera);
		}
		function Animer() {
			requestAnimationFrame(Animer);

			// Keyboard movement inputs
			if (keyboard[38]) { // avancer
				controls.getObject().translateZ(-player.speed)
			}
			if (keyboard[40]) { // reculer
				controls.getObject().translateZ(player.speed)
			}
			if (keyboard[37]) { // gauche
				controls.getObject().translateX(-player.speed)
			}
			if (keyboard[39]) { // droite
				controls.getObject().translateX(player.speed)
			}			

			// Collisions
			if (camera.position.z > 11)
				camera.position.z = 11
			else if (camera.position.z < -11)
				camera.position.z = -11

			if (camera.position.x > 5.5)
				camera.position.x = 5.5
			else if (camera.position.x < -5.5)
				camera.position.x = -5.5

			camera.position.y = -20.5;

			coordCubes.forEach(function(coordCube) {
				if (camera.position.x > (coordCube[0]-0.5) && camera.position.x < (coordCube[0]+0.5)) {
					if (camera.position.z > (coordCube[1]-0.5) && camera.position.z < (coordCube[1]+0.5)) {
						console.log("GET CUBED " + coordCube)
						let index = coordCubes.indexOf(coordCube);
						if (index > -1) {
							// collision avec un cube
							coordCubes.splice(index, 1);
							index = coordCubesOriginal.indexOf(coordCube);
							scene.remove(scene.getObjectByName("cube" + index));
							nbCubes++;
							if (3-nbCubes > 0)
								document.getElementById("score").innerHTML = "Cube found ! " + (3-nbCubes) + " remaining";
							else
								document.getElementById("score").innerHTML = "You won !";
						}
					}
				}
			});

			Afficher();
		}

		function keyDown(event) {
			keyboard[event.keyCode] = true;
		}

		function keyUp(event) {
			keyboard[event.keyCode] = false;
		}

		window.addEventListener('keydown', keyDown);
		window.addEventListener('keyup', keyUp);

		Init();
		Animer();

	</script>
	<p id="score" style="margin: 0.25em; font-weight: bold;">0 golden cubes found, 3 remaining...</p>
</body>

</html>